{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"extending/","title":"Adding New Frameworks","text":"<p>Adding a new data model framework is pretty straightforward. There are three key elements involved, all found in the <code>erdantic.base</code> module.</p> <ol> <li><code>Field</code>: The adapter interface for fields on the data model classes from whatever framework</li> <li><code>Model</code>: The adapter interface for those models themselves</li> <li><code>@register_model_adapter</code>: The decorator you use to register a concrete model adapter so that <code>erdantic</code> knows about it</li> </ol> <p>You will be making concrete subclasses of the <code>Field</code> and <code>Model</code> abstract base classes and filling in several abstract methods.</p> <p>Some tips:</p> <ul> <li>You can check out the docstrings on the base classes to understand what methods are supposed to do.</li> <li>You can also use the source code for the <code>erdantic.pydantic</code> or <code>erdantic.dataclasses</code> modules as examples.</li> <li>The erdantic library is thoroughly type-annotated, so you can use a static typechecker like mypy to help you ensure correctness.</li> </ul>"},{"location":"extending/#field-subclass","title":"Field Subclass","text":"<p>First, make a subclass of <code>Field</code>. You can use the template below, which stubs out all of the abstract methods, to get started. You should replace <code>MyDataField</code>\u2014both in the class definition and in the <code>__init__</code> method definition\u2014with the actual class of field objects in the framework you're adapting. Then fill in the rest of the methods that are being passed.</p> <pre><code>from erdantic.base import Field, InvalidFieldError\n\n\nclass MyField(Field[MyDataField]):\n\n    def __init__(self, field: MyDataField):\n        if not isinstance(field, MyDataField):\n            raise InvalidFieldError(f\"field must be of type MyDataField. Got: {type(field)}\")\n        super().__init__(field=field)\n\n    @property\n    def name(self) -&gt; str:\n        pass\n\n    @property\n    def type_obj(self) -&gt; type:\n        pass\n\n    def is_many(self) -&gt; bool:\n        pass\n\n    def is_nullable(self) -&gt; bool:\n        pass\n</code></pre>"},{"location":"extending/#model-subclass-and-decorator","title":"Model Subclass and Decorator","text":"<p>Next, make a subclass of <code>Model</code>. It is similarly an abstract base class. Check out the template below with the required methods stubbed. Replace <code>MyDataClass</code> in the class declaration and in <code>__init__</code> with the actual class of the data class you're adapting.</p> <p>You'll also need to decorate this class with <code>@register_model_adapter</code>. Note that it is actually a decorator factory; calling it with a string input returns the actual decorator. The string input should be a concise unique identifier for your framework, such as the name of its package.</p> <pre><code>from erdantic.base import InvalidModelError, Model, register_model_adapter\nfrom erdantic.typing import repr_type_with_mro\n\n\n@register_model_adapter(\"mydataclass\")\nclass MyModel(Model[MyDataClass]):\n\n    def __init__(self, model: Type[MyDataClass]):\n        if not self.is_model_type(model):\n            raise InvalidModelError(\n                \"Argument model must be a subclass of MyDataClass. \"\n                f\"Got {repr_type_with_mro(model)}\"\n            )\n        super().__init__(model=model)\n\n    @staticmethod\n    def is_model_type(obj: Any) -&gt; bool:\n        pass\n\n    @property\n    def fields(self) -&gt; List[Field]:\n        pass\n</code></pre>"},{"location":"forward-references/","title":"Handling Forward References","text":"<p>Forward references are type annotations which use a string literal to declare a name that hasn't been defined yet in the code. The annotation is stored as just the name and the reference to the object is resolved later. Forward references are often useful when a class' type hints need to reference itself, or when you need to avoid a circular import through <code>if typing.TYPE_CHECKING</code>.</p> <p>Dealing with forward reference resolution is somewhat tricky. In the best case, your forward references are already resolved, and erdantic will work without any issue. Otherwise, the following sections will provide some examples of expected errors and what to do.</p>"},{"location":"forward-references/#unevaluated-forward-references","title":"Unevaluated Forward References","text":"<p>Forward references must be evaluated along with the right namespace in order to properly resolve them to the correct class. If you are using forward references and they are unresolved, erdantic will error with an <code>UnevaluatedForwardRefError</code>. The exception message will provide some information about how to resolve the forward references.</p> Pydanticdataclasses <pre><code>from typing import List\n\nimport erdantic as erd\nfrom pydantic import BaseModel\n\n\nclass Container(BaseModel):\n    contains: List[\"Item\"]\n\n\nclass Item(BaseModel):\n    name: str\n\n# Error because forward reference is unresolved\ndiagram = erd.create(Container)\n#&gt; Traceback (most recent call last):\n#&gt;   File \"&lt;string&gt;\", line 2, in &lt;module&gt;\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 192, in create\n#&gt;     search_composition_graph(model=model, seen_models=seen_models, seen_edges=seen_edges)\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 241, in search_composition_graph\n#&gt;     raise UnevaluatedForwardRefError(\n#&gt; erdantic.exceptions.UnevaluatedForwardRefError: Unevaluated forward reference 'Item' for field contains on model Container. Call 'update_forward_refs' after model is created to resolve. See: https://pydantic-docs.helpmanual.io/usage/postponed_annotations/\n\n# Explicitly force evaluation\nContainer.update_forward_refs(**locals())\n\n# Now this works fine\ndiagram = erd.create(Container)\ndiagram.edges\n#&gt; [ Edge(source=PydanticModel(Container), source_field=&lt;PydanticField: 'contains', List[Item]&gt;, target=PydanticModel(Item))]\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom typing import get_type_hints, List\n\nimport erdantic as erd\n\n\n@dataclass\nclass Container:\n    contains: List[\"Item\"]\n\n\n@dataclass\nclass Item:\n    name: str\n\n\n# Error because forward reference is unresolved\ndiagram = erd.create(Container)\n#&gt; Traceback (most recent call last):\n#&gt;   File \"/Users/jqi/miniconda3/envs/erdantic39/lib/python3.9/site-packages/reprexlite/code.py\", line 71, in evaluate\n#&gt;     exec(str(self).strip(), scope, scope)\n#&gt;   File \"&lt;string&gt;\", line 2, in &lt;module&gt;\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 192, in create\n#&gt;     search_composition_graph(model=model, seen_models=seen_models, seen_edges=seen_edges)\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 241, in search_composition_graph\n#&gt;     raise UnevaluatedForwardRefError(\n#&gt; erdantic.exceptions.UnevaluatedForwardRefError: Unevaluated forward reference 'Item' for field contains on model Container. Call 'typing.get_type_hints' on your dataclass after creating it to resolve.\n\n# Explicitly force evaluation\n_ = get_type_hints(Container, localns=locals())\n\n# Now this works fine\ndiagram = erd.create(Container)\ndiagram.edges\n#&gt; [ Edge(source=DataClassModel(Container), source_field=&lt;DataClassField: 'contains', List[Item]&gt;, target=DataClassModel(Item))]\n</code></pre>"},{"location":"forward-references/#untransformed-string-forward-references","title":"Untransformed String Forward References","text":"<p>Under the hood, forward references usually\u2014but not always\u2014get converted from a string to a <code>typing.ForwardRef</code> instances. These objects track metadata about the type annotation, including what they get evaluated to.</p> <p>Unfortunately, sometimes the annotations remain as unconverted strings, and erdantic is unable to handle those cases. In such cases, erdantic will error with a <code>StringForwardRefError</code>. To work around that, you can explicitly declare those annotations with <code>typing.ForwardRef</code>.</p> Pydanticdataclasses <p>Pydantic does this automatically and doesn't need any further intervention.</p> <pre><code>import erdantic as erd\nfrom pydantic import BaseModel\n\n\nclass SingleContainer(BaseModel):\n    contains: \"Item\"\n\n\nclass Item(BaseModel):\n    name: str\n\n# Works without any issues\nSingleContainer.update_forward_refs(**locals())\ndiagram = erd.create(SingleContainer)\ndiagram.edges\n#&gt; [ Edge(source=PydanticModel(SingleContainer), source_field=&lt;PydanticField: 'contains', Item&gt;, target=PydanticModel(Item))]\n</code></pre> <p>dataclasses sometimes do not convert from strings and require explicit use of <code>typing.ForwardRef</code>.</p> <pre><code>from dataclasses import dataclass\nfrom typing import get_type_hints, ForwardRef\n\nimport erdantic as erd\n\n\n@dataclass\nclass SingleContainer:\n    contains: \"Item\"\n\n\n@dataclass\nclass Item:\n    name: str\n\n\n# Errors because string annotation is unconverted\n_ = get_type_hints(SingleContainer, localns=locals())\ndiagram = erd.create(SingleContainer)\n#&gt; Traceback (most recent call last):\n#&gt;   File \"&lt;string&gt;\", line 1, in &lt;module&gt;\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 192, in create\n#&gt;     search_composition_graph(model=model, seen_models=seen_models, seen_edges=seen_edges)\n#&gt;   File \"/Users/jqi/repos/erdantic/erdantic/erd.py\", line 245, in search_composition_graph\n#&gt;     raise StringForwardRefError(\n#&gt; erdantic.exceptions.StringForwardRefError: Forward reference 'Item' for field 'contains' on model 'SingleContainer' is a string literal and not a typing.ForwardRef object. erdantic is unable to handle forward references that aren't transformed into typing.ForwardRef. Declare explicitly with 'typing.ForwardRef(\"Item\", is_argument=False)'.\n\n\n@dataclass\nclass FixedSingleContainer:\n    contains: ForwardRef(\"Item\", is_argument=False)\n\n\n# Now this works fine\n_ = get_type_hints(FixedSingleContainer, localns=locals())\ndiagram = erd.create(FixedSingleContainer)\ndiagram.edges\n#&gt; [ Edge(source=DataClassModel(FixedSingleContainer), source_field=&lt;DataClassField: 'contains', Item&gt;, target=DataClassModel(Item))]\n</code></pre> <p><sup>Examples created with reprexlite.</sup></p>"},{"location":"api-reference/base/","title":"erdantic.base","text":""},{"location":"api-reference/base/#erdantic.base.FT","title":"<code>FT = TypeVar('FT', bound=Any, covariant=True)</code>  <code>module-attribute</code>","text":"<p>Type variable for a field object adapted by adapter class <code>Field</code>.</p>"},{"location":"api-reference/base/#erdantic.base.MT","title":"<code>MT = TypeVar('MT', bound=type, covariant=True)</code>  <code>module-attribute</code>","text":"<p>Type variable for a data model class adapted by adapter class <code>Model</code>. Bounded by <code>type</code>.</p>"},{"location":"api-reference/base/#erdantic.base.model_adapter_registry","title":"<code>model_adapter_registry: Dict[str, Type[Model]] = {}</code>  <code>module-attribute</code>","text":"<p>Registry of concrete <code>Model</code> adapter subclasses. A concrete <code>Model</code> subclass must be registered for it to be available to the diagram creation workflow.</p>"},{"location":"api-reference/base/#erdantic.base.Field","title":"<code>Field</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[FT]</code></p> <p>Abstract base class that adapts a field object of a data model class to work with erdantic. Concrete implementations should subclass and implement abstract methods.</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>FT</code> <p>Field object on a data model class associated with this adapter</p> Source code in <code>erdantic/base.py</code> <pre><code>class Field(ABC, Generic[FT]):\n    \"\"\"Abstract base class that adapts a field object of a data model class to work with erdantic.\n    Concrete implementations should subclass and implement abstract methods.\n\n    Attributes:\n        field (FT): Field object on a data model class associated with this adapter\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self, field: FT):\n        \"\"\"Initialize Field adapter instance.\n\n        Args:\n            field: Field object to associate with this adapter instance\n        \"\"\"\n        self.field: Final[FT] = field\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:  # pragma: no cover\n        \"\"\"Name of this field on the parent data model.\"\"\"\n\n    @property\n    @abstractmethod\n    def type_obj(self) -&gt; Union[type, GenericAlias]:\n        \"\"\"Python type object for this field.\"\"\"\n        pass\n\n    @abstractmethod\n    def is_many(self) -&gt; bool:  # pragma: no cover\n        \"\"\"Check whether this field represents a one-to-one or one-to-many relationship.\n\n        Returns:\n            bool: True if one-to-many relationship, else False.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_nullable(self) -&gt; bool:  # pragma: no cover\n        \"\"\"Check whether this field is nullable, i.e., can be `None`.\n\n        Returns:\n            bool: True if nullable, else False.\n        \"\"\"\n        pass\n\n    @property\n    def type_name(self) -&gt; str:  # pragma: no cover\n        \"\"\"String representation of the Python type annotation for this field.\"\"\"\n        return repr_type(self.type_obj)\n\n    def dot_row(self) -&gt; str:\n        \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field\n        that is part of a table describing the field's parent data model. It is used as part the\n        `label` attribute of data model's node in the graph's DOT representation.\n\n        Returns:\n            str: DOT language for table row\n        \"\"\"\n        return _row_template.format(name=self.name, type_name=self.type_name)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, type(self)) and hash(self) == hash(other)\n\n    def __hash__(self) -&gt; int:\n        return id(self.field)\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{type(self).__name__}: '{self.name}', {self.type_name}&gt;\"\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Field.name","title":"<code>name: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Name of this field on the parent data model.</p>"},{"location":"api-reference/base/#erdantic.base.Field.type_name","title":"<code>type_name: str</code>  <code>property</code>","text":"<p>String representation of the Python type annotation for this field.</p>"},{"location":"api-reference/base/#erdantic.base.Field.type_obj","title":"<code>type_obj: Union[type, GenericAlias]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Python type object for this field.</p>"},{"location":"api-reference/base/#erdantic.base.Field.__init__","title":"<code>__init__(field)</code>  <code>abstractmethod</code>","text":"<p>Initialize Field adapter instance.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>FT</code> <p>Field object to associate with this adapter instance</p> required Source code in <code>erdantic/base.py</code> <pre><code>@abstractmethod\ndef __init__(self, field: FT):\n    \"\"\"Initialize Field adapter instance.\n\n    Args:\n        field: Field object to associate with this adapter instance\n    \"\"\"\n    self.field: Final[FT] = field\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Field.dot_row","title":"<code>dot_row()</code>","text":"<p>Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field that is part of a table describing the field's parent data model. It is used as part the <code>label</code> attribute of data model's node in the graph's DOT representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOT language for table row</p> Source code in <code>erdantic/base.py</code> <pre><code>def dot_row(self) -&gt; str:\n    \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field\n    that is part of a table describing the field's parent data model. It is used as part the\n    `label` attribute of data model's node in the graph's DOT representation.\n\n    Returns:\n        str: DOT language for table row\n    \"\"\"\n    return _row_template.format(name=self.name, type_name=self.type_name)\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Field.is_many","title":"<code>is_many()</code>  <code>abstractmethod</code>","text":"<p>Check whether this field represents a one-to-one or one-to-many relationship.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if one-to-many relationship, else False.</p> Source code in <code>erdantic/base.py</code> <pre><code>@abstractmethod\ndef is_many(self) -&gt; bool:  # pragma: no cover\n    \"\"\"Check whether this field represents a one-to-one or one-to-many relationship.\n\n    Returns:\n        bool: True if one-to-many relationship, else False.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Field.is_nullable","title":"<code>is_nullable()</code>  <code>abstractmethod</code>","text":"<p>Check whether this field is nullable, i.e., can be <code>None</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if nullable, else False.</p> Source code in <code>erdantic/base.py</code> <pre><code>@abstractmethod\ndef is_nullable(self) -&gt; bool:  # pragma: no cover\n    \"\"\"Check whether this field is nullable, i.e., can be `None`.\n\n    Returns:\n        bool: True if nullable, else False.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Model","title":"<code>Model</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[MT]</code></p> <p>Abstract base class that adapts a data model class to work with erdantic. Instances represent a node in our entity relationship diagram graph. Concrete implementations should subclass and implement abstract methods.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>MT</code> <p>Data model class associated with this adapter</p> <code>forward_ref_help</code> <code>Optional[str]</code> <p>Instructions for how to resolve an unevaluated forward reference in a field's type declaration.</p> Source code in <code>erdantic/base.py</code> <pre><code>class Model(ABC, Generic[MT]):\n    \"\"\"Abstract base class that adapts a data model class to work with erdantic. Instances\n    represent a node in our entity relationship diagram graph. Concrete implementations should\n    subclass and implement abstract methods.\n\n    Attributes:\n        model (MT): Data model class associated with this adapter\n        forward_ref_help (Optional[str]): Instructions for how to resolve an unevaluated forward\n            reference in a field's type declaration.\n    \"\"\"\n\n    forward_ref_help: Optional[str] = None\n\n    @abstractmethod\n    def __init__(self, model: MT):\n        \"\"\"Initialize model adapter instance.\n\n        Args:\n            model: Data model class to associate with this adapter instance\n        \"\"\"\n        self.model: Final[MT] = model\n\n    @property\n    @abstractmethod\n    def fields(self) -&gt; List[Field]:  # pragma: no cover\n        \"\"\"List of fields defined on this data model.\"\"\"\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def is_model_type(obj: Any) -&gt; bool:  # pragma: no cover\n        \"\"\"Check if object is the type of data model class that this model adapter works with.\"\"\"\n        pass\n\n    @property\n    def name(self) -&gt; str:  # pragma: no cover\n        \"\"\"Name of this data model.\"\"\"\n        return self.model.__name__\n\n    @property\n    def docstring(self) -&gt; str:\n        \"\"\"Docstring for this data model.\"\"\"\n        out = f\"{self.model.__module__}.{self.model.__qualname__}\"\n        docstring = inspect.getdoc(self.model)\n        if docstring:\n            out += \"\\n\\n\" + docstring + \"\\n\"\n        return out\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"Human-readable unique identifier for this data model. Should be stable across\n        sessions.\"\"\"\n        return f\"{self.model.__module__}.{self.model.__qualname__}\"\n\n    def dot_label(self) -&gt; str:\n        \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a table for this data\n        model. It is used as the `label` attribute of data model's node in the graph's DOT\n        representation.\n\n        Returns:\n            str: DOT language for table\n        \"\"\"\n        rows = \"\\n\".join(field.dot_row() for field in self.fields)\n        return _table_template.format(name=self.name, rows=rows).replace(\"\\n\", \"\")\n\n    def __eq__(self, other) -&gt; bool:\n        return isinstance(other, type(self)) and hash(self) == hash(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.key)\n\n    def __lt__(self, other) -&gt; bool:\n        if isinstance(other, Model):\n            return self.key &lt; other.key\n        return NotImplemented\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self).__name__}({self.name})\"\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Model.docstring","title":"<code>docstring: str</code>  <code>property</code>","text":"<p>Docstring for this data model.</p>"},{"location":"api-reference/base/#erdantic.base.Model.fields","title":"<code>fields: List[Field]</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>List of fields defined on this data model.</p>"},{"location":"api-reference/base/#erdantic.base.Model.key","title":"<code>key: str</code>  <code>property</code>","text":"<p>Human-readable unique identifier for this data model. Should be stable across sessions.</p>"},{"location":"api-reference/base/#erdantic.base.Model.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Name of this data model.</p>"},{"location":"api-reference/base/#erdantic.base.Model.__init__","title":"<code>__init__(model)</code>  <code>abstractmethod</code>","text":"<p>Initialize model adapter instance.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MT</code> <p>Data model class to associate with this adapter instance</p> required Source code in <code>erdantic/base.py</code> <pre><code>@abstractmethod\ndef __init__(self, model: MT):\n    \"\"\"Initialize model adapter instance.\n\n    Args:\n        model: Data model class to associate with this adapter instance\n    \"\"\"\n    self.model: Final[MT] = model\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Model.dot_label","title":"<code>dot_label()</code>","text":"<p>Returns the DOT language \"HTML-like\" syntax specification of a table for this data model. It is used as the <code>label</code> attribute of data model's node in the graph's DOT representation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOT language for table</p> Source code in <code>erdantic/base.py</code> <pre><code>def dot_label(self) -&gt; str:\n    \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a table for this data\n    model. It is used as the `label` attribute of data model's node in the graph's DOT\n    representation.\n\n    Returns:\n        str: DOT language for table\n    \"\"\"\n    rows = \"\\n\".join(field.dot_row() for field in self.fields)\n    return _table_template.format(name=self.name, rows=rows).replace(\"\\n\", \"\")\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.Model.is_model_type","title":"<code>is_model_type(obj)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Check if object is the type of data model class that this model adapter works with.</p> Source code in <code>erdantic/base.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef is_model_type(obj: Any) -&gt; bool:  # pragma: no cover\n    \"\"\"Check if object is the type of data model class that this model adapter works with.\"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/base/#erdantic.base.register_model_adapter","title":"<code>register_model_adapter(type_name)</code>","text":"<p>Create decorator to register a concrete <code>Model</code> adapter subclass that will be identified under the key <code>type_name</code>. A concrete <code>Model</code> subclass must be registered for it to be available to the diagram creation workflow.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>Key used to identify concrete <code>Model</code> adapter subclass</p> required <p>Returns:</p> Type Description <code>Callable[[Type[Model]], Type[Model]]</code> <p>Callable[[Type[Model]], Type[Model]]: A registration decorator for a concrete <code>Model</code> adapter subclass</p> Source code in <code>erdantic/base.py</code> <pre><code>def register_model_adapter(type_name: str) -&gt; Callable[[Type[Model]], Type[Model]]:\n    \"\"\"Create decorator to register a concrete [`Model`][erdantic.base.Model] adapter subclass\n    that will be identified under the key `type_name`. A concrete `Model` subclass must be\n    registered for it to be available to the diagram creation workflow.\n\n    Args:\n        type_name (str): Key used to identify concrete `Model` adapter subclass\n\n    Returns:\n        Callable[[Type[Model]], Type[Model]]: A registration decorator for a concrete `Model`\n            adapter subclass\n    \"\"\"\n\n    def decorator(cls: type) -&gt; type:\n        global model_adapter_registry\n        if not issubclass(cls, Model):\n            raise InvalidModelAdapterError(\n                \"Only subclasses of erdantic.base.Model can be \"\n                \"registered as erdantic model adapters.\"\n            )\n        model_adapter_registry[type_name] = cls\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api-reference/dataclasses/","title":"erdantic.dataclasses","text":""},{"location":"api-reference/dataclasses/#erdantic.dataclasses.DataClassField","title":"<code>DataClassField</code>","text":"<p>             Bases: <code>Field[Field]</code></p> <p>Concrete field adapter class for dataclass fields.</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>Field</code> <p>The dataclass field instance that is associated with this adapter instance.</p> Source code in <code>erdantic/dataclasses.py</code> <pre><code>class DataClassField(Field[dataclasses.Field]):\n    \"\"\"Concrete field adapter class for dataclass fields.\n\n    Attributes:\n        field (dataclasses.Field): The dataclass field instance that is associated with this\n            adapter instance.\n    \"\"\"\n\n    def __init__(self, field: dataclasses.Field):\n        if not isinstance(field, dataclasses.Field):\n            raise InvalidFieldError(f\"field must be of type dataclasses.Field. Got: {type(field)}\")\n        super().__init__(field=field)\n\n    @property\n    def name(self) -&gt; str:\n        return self.field.name\n\n    @property\n    def type_obj(self) -&gt; Union[type, GenericAlias]:\n        return self.field.type\n\n    def is_many(self) -&gt; bool:\n        return is_many(self.type_obj)\n\n    def is_nullable(self) -&gt; bool:\n        return is_nullable(self.type_obj)\n</code></pre>"},{"location":"api-reference/dataclasses/#erdantic.dataclasses.DataClassModel","title":"<code>DataClassModel</code>","text":"<p>             Bases: <code>Model[type]</code></p> <p>Concrete model adapter class for a <code>dataclasses</code> module dataclass.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>type</code> <p>The dataclass that is associated with this adapter instance.</p> <code>forward_ref_help</code> <code>Optional[str]</code> <p>Instructions for how to resolve an unevaluated forward reference in a field's type declaration.</p> Source code in <code>erdantic/dataclasses.py</code> <pre><code>@register_model_adapter(\"dataclasses\")\nclass DataClassModel(Model[type]):\n    \"\"\"Concrete model adapter class for a\n    [`dataclasses` module](https://docs.python.org/3/library/dataclasses.html) dataclass.\n\n    Attributes:\n        model (type): The dataclass that is associated with this adapter instance.\n        forward_ref_help (Optional[str]): Instructions for how to resolve an unevaluated forward\n            reference in a field's type declaration.\n    \"\"\"\n\n    forward_ref_help = (\n        \"Call 'typing.get_type_hints' on your dataclass after creating it to resolve.\"\n    )\n\n    def __init__(self, model: type):\n        if not self.is_model_type(model):\n            raise InvalidModelError(f\"Argument model must be a dataclass: {repr(model)}\")\n        super().__init__(model=model)\n\n    @staticmethod\n    def is_model_type(obj: Any) -&gt; bool:\n        return isinstance(obj, type) and dataclasses.is_dataclass(obj)\n\n    @property\n    def fields(self) -&gt; List[Field]:\n        return [DataClassField(field=f) for f in dataclasses.fields(self.model)]\n</code></pre>"},{"location":"api-reference/erd/","title":"erdantic.erd","text":""},{"location":"api-reference/erd/#erdantic.erd.Edge","title":"<code>Edge</code>","text":"<p>Class for an edge in the entity relationship diagram graph. Represents the composition relationship between a composite model (<code>source</code> via <code>source_field</code>) with a component model (<code>target</code>).</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Model</code> <p>Composite data model.</p> <code>source_field</code> <code>Field</code> <p>Field on <code>source</code> that has type of `target.</p> <code>target</code> <code>Model</code> <p>Component data model.</p> Source code in <code>erdantic/erd.py</code> <pre><code>class Edge:\n    \"\"\"Class for an edge in the entity relationship diagram graph. Represents the composition\n    relationship between a composite model (`source` via `source_field`) with a component model\n    (`target`).\n\n    Attributes:\n        source (Model): Composite data model.\n        source_field (Field): Field on `source` that has type of `target.\n        target (Model): Component data model.\n    \"\"\"\n\n    source: \"Model\"\n    source_field: \"Field\"\n    target: \"Model\"\n\n    def __init__(self, source: \"Model\", source_field: \"Field\", target: \"Model\"):\n        if source_field not in set(source.fields):\n            raise UnknownFieldError(\n                f\"source_field {source_field} is not a field of source {source}\"\n            )\n        self.source = source\n        self.source_field = source_field\n        self.target = target\n\n    def dot_arrowhead(self) -&gt; str:\n        \"\"\"Arrow shape specification in Graphviz DOT language for this edge's head. See\n        [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a reference. Shape returned\n        is based on [crow's foot notation](https://www.calebcurry.com/cardinality-and-modality/)\n        for the relationship's cardinality and modality.\n\n        Returns:\n            str: DOT language specification for arrow shape of this edge's head\n        \"\"\"\n        cardinality = \"crow\" if self.source_field.is_many() else \"nonetee\"\n        modality = (\n            \"odot\" if self.source_field.is_nullable() or self.source_field.is_many() else \"tee\"\n        )\n        return cardinality + modality\n\n    def __hash__(self) -&gt; int:\n        return hash((self.source, self.source_field, self.target))\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, type(self)) and hash(self) == hash(other)\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"Edge(source={repr(self.source)}, source_field={self.source_field}, \"\n            f\"target={self.target})\"\n        )\n\n    def __lt__(self, other) -&gt; bool:\n        if isinstance(other, Edge):\n            self_key = (self.source, self.source.fields.index(self.source_field), self.target)\n            other_key = (other.source, other.source.fields.index(other.source_field), other.target)\n            return self_key &lt; other_key\n        return NotImplemented\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.Edge.dot_arrowhead","title":"<code>dot_arrowhead()</code>","text":"<p>Arrow shape specification in Graphviz DOT language for this edge's head. See Graphviz docs as a reference. Shape returned is based on crow's foot notation for the relationship's cardinality and modality.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOT language specification for arrow shape of this edge's head</p> Source code in <code>erdantic/erd.py</code> <pre><code>def dot_arrowhead(self) -&gt; str:\n    \"\"\"Arrow shape specification in Graphviz DOT language for this edge's head. See\n    [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a reference. Shape returned\n    is based on [crow's foot notation](https://www.calebcurry.com/cardinality-and-modality/)\n    for the relationship's cardinality and modality.\n\n    Returns:\n        str: DOT language specification for arrow shape of this edge's head\n    \"\"\"\n    cardinality = \"crow\" if self.source_field.is_many() else \"nonetee\"\n    modality = (\n        \"odot\" if self.source_field.is_nullable() or self.source_field.is_many() else \"tee\"\n    )\n    return cardinality + modality\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.EntityRelationshipDiagram","title":"<code>EntityRelationshipDiagram</code>","text":"<p>Class for entity relationship diagram.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>List[Model]</code> <p>Data models (nodes) in diagram.</p> <code>attr2</code> <code>List[Edge]</code> <p>Edges in diagram, representing the composition relationship between models.</p> Source code in <code>erdantic/erd.py</code> <pre><code>class EntityRelationshipDiagram:\n    \"\"\"Class for entity relationship diagram.\n\n    Attributes:\n        models (List[Model]): Data models (nodes) in diagram.\n        attr2 (List[Edge]): Edges in diagram, representing the composition relationship between\n            models.\n    \"\"\"\n\n    models: List[\"Model\"]\n    edges: List[\"Edge\"]\n\n    def __init__(self, models: Sequence[\"Model\"], edges: Sequence[\"Edge\"]):\n        self.models = sorted(models)\n        self.edges = sorted(edges)\n\n    def draw(self, out: Union[str, os.PathLike], **kwargs):\n        \"\"\"Render entity relationship diagram for given data model classes to file.\n\n        Args:\n            out (Union[str, os.PathLike]): Output file path for rendered diagram.\n            **kwargs: Additional keyword arguments to [`pygraphviz.AGraph.draw`](https://pygraphviz.github.io/documentation/latest/reference/agraph.html#pygraphviz.AGraph.draw).\n        \"\"\"\n        self.graph().draw(out, prog=\"dot\", **kwargs)\n\n    def graph(self) -&gt; pgv.AGraph:\n        \"\"\"Return [`pygraphviz.AGraph`](https://pygraphviz.github.io/documentation/latest/reference/agraph.html)\n        instance for diagram.\n\n        Returns:\n            pygraphviz.AGraph: graph object for diagram\n        \"\"\"\n        g = pgv.AGraph(\n            directed=True,\n            strict=False,\n            nodesep=0.5,\n            ranksep=1.5,\n            rankdir=\"LR\",\n            name=\"Entity Relationship Diagram\",\n            label=f\"Created by erdantic v{__version__} &lt;https://github.com/drivendataorg/erdantic&gt;\",\n            fontsize=9,\n            fontcolor=\"gray66\",\n        )\n        g.node_attr[\"fontsize\"] = 14\n        g.node_attr[\"shape\"] = \"plain\"\n        for model in self.models:\n            g.add_node(\n                model.key,\n                label=model.dot_label(),\n                tooltip=model.docstring.replace(\"\\n\", \"&amp;#xA;\"),\n            )\n        for edge in self.edges:\n            g.add_edge(\n                edge.source.key,\n                edge.target.key,\n                tailport=f\"{edge.source_field.name}:e\",\n                headport=\"_root:w\",\n                arrowhead=edge.dot_arrowhead(),\n            )\n        return g\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation\n        of entity relationship diagram for given data model classes.\n\n        Returns:\n            str: DOT language representation of diagram\n        \"\"\"\n        return self.graph().string()\n\n    def __hash__(self) -&gt; int:\n        return hash((tuple(self.models), tuple(self.edges)))\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, type(self)) and hash(self) == hash(other)\n\n    def __repr__(self) -&gt; str:\n        models = \", \".join(repr(m) for m in self.models)\n        edges = \", \".join(repr(e) for e in self.edges)\n        return f\"EntityRelationshipDiagram(models=[{models}], edges=[{edges}])\"\n\n    def _repr_png_(self) -&gt; bytes:\n        graph = self.graph()\n        return graph.draw(prog=\"dot\", format=\"png\")\n\n    def _repr_svg_(self) -&gt; str:\n        graph = self.graph()\n        return graph.draw(prog=\"dot\", format=\"svg\").decode(graph.encoding)\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.EntityRelationshipDiagram.draw","title":"<code>draw(out, **kwargs)</code>","text":"<p>Render entity relationship diagram for given data model classes to file.</p> <p>Parameters:</p> Name Type Description Default <code>out</code> <code>Union[str, PathLike]</code> <p>Output file path for rendered diagram.</p> required <code>**kwargs</code> <p>Additional keyword arguments to <code>pygraphviz.AGraph.draw</code>.</p> <code>{}</code> Source code in <code>erdantic/erd.py</code> <pre><code>def draw(self, out: Union[str, os.PathLike], **kwargs):\n    \"\"\"Render entity relationship diagram for given data model classes to file.\n\n    Args:\n        out (Union[str, os.PathLike]): Output file path for rendered diagram.\n        **kwargs: Additional keyword arguments to [`pygraphviz.AGraph.draw`](https://pygraphviz.github.io/documentation/latest/reference/agraph.html#pygraphviz.AGraph.draw).\n    \"\"\"\n    self.graph().draw(out, prog=\"dot\", **kwargs)\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.EntityRelationshipDiagram.graph","title":"<code>graph()</code>","text":"<p>Return <code>pygraphviz.AGraph</code> instance for diagram.</p> <p>Returns:</p> Type Description <code>AGraph</code> <p>pygraphviz.AGraph: graph object for diagram</p> Source code in <code>erdantic/erd.py</code> <pre><code>def graph(self) -&gt; pgv.AGraph:\n    \"\"\"Return [`pygraphviz.AGraph`](https://pygraphviz.github.io/documentation/latest/reference/agraph.html)\n    instance for diagram.\n\n    Returns:\n        pygraphviz.AGraph: graph object for diagram\n    \"\"\"\n    g = pgv.AGraph(\n        directed=True,\n        strict=False,\n        nodesep=0.5,\n        ranksep=1.5,\n        rankdir=\"LR\",\n        name=\"Entity Relationship Diagram\",\n        label=f\"Created by erdantic v{__version__} &lt;https://github.com/drivendataorg/erdantic&gt;\",\n        fontsize=9,\n        fontcolor=\"gray66\",\n    )\n    g.node_attr[\"fontsize\"] = 14\n    g.node_attr[\"shape\"] = \"plain\"\n    for model in self.models:\n        g.add_node(\n            model.key,\n            label=model.dot_label(),\n            tooltip=model.docstring.replace(\"\\n\", \"&amp;#xA;\"),\n        )\n    for edge in self.edges:\n        g.add_edge(\n            edge.source.key,\n            edge.target.key,\n            tailport=f\"{edge.source_field.name}:e\",\n            headport=\"_root:w\",\n            arrowhead=edge.dot_arrowhead(),\n        )\n    return g\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.EntityRelationshipDiagram.to_dot","title":"<code>to_dot()</code>","text":"<p>Generate Graphviz DOT language representation of entity relationship diagram for given data model classes.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOT language representation of diagram</p> Source code in <code>erdantic/erd.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation\n    of entity relationship diagram for given data model classes.\n\n    Returns:\n        str: DOT language representation of diagram\n    \"\"\"\n    return self.graph().string()\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.adapt_model","title":"<code>adapt_model(obj)</code>","text":"<p>Dispatch object to appropriate concrete <code>Model</code> adapter subclass and return instantiated adapter instance.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Data model class to adapt</p> required <p>Raises:</p> Type Description <code>UnknownModelTypeError</code> <p>If obj does not match registered Model adapter classes</p> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>Instantiated concrete <code>Model</code> subclass instance</p> Source code in <code>erdantic/erd.py</code> <pre><code>def adapt_model(obj: Any) -&gt; Model:\n    \"\"\"Dispatch object to appropriate concrete [`Model`][erdantic.base.Model] adapter subclass and\n    return instantiated adapter instance.\n\n    Args:\n        obj (Any): Data model class to adapt\n\n    Raises:\n        UnknownModelTypeError: If obj does not match registered Model adapter classes\n\n    Returns:\n        Model: Instantiated concrete `Model` subclass instance\n    \"\"\"\n    for model_adapter in model_adapter_registry.values():\n        if model_adapter.is_model_type(obj):\n            return model_adapter(obj)\n    raise UnknownModelTypeError(model=obj)\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.create","title":"<code>create(*models_or_modules, termini=[], limit_search_models_to=None)</code>","text":"<p>Construct <code>EntityRelationshipDiagram</code> from given data model classes.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type</code> <p>Data model classes to diagram or modules containing them.</p> <code>()</code> <code>termini</code> <code>Sequence[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>[]</code> <code>limit_search_models_to</code> <code>Optional[Iterable[sr]]</code> <p>Iterable of identifiers of data model classes that erdantic supports. If any are specified, when searching a module, limit data model classes to those ones. Defaults to None which will find all data model classes supported by erdantic.</p> <code>None</code> <p>Raises:     UnknownModelTypeError: If model is not recognized as a supported model type.</p> <p>Returns:</p> Name Type Description <code>EntityRelationshipDiagram</code> <code>EntityRelationshipDiagram</code> <p>diagram object for given data model.</p> Source code in <code>erdantic/erd.py</code> <pre><code>def create(\n    *models_or_modules: Union[type, ModuleType],\n    termini: Sequence[type] = [],\n    limit_search_models_to: Optional[Iterable[str]] = None,\n) -&gt; EntityRelationshipDiagram:\n    \"\"\"Construct [`EntityRelationshipDiagram`][erdantic.erd.EntityRelationshipDiagram] from given\n    data model classes.\n\n    Args:\n        *models_or_modules (type): Data model classes to diagram or modules containing them.\n        termini (Sequence[type]): Data model classes to set as terminal nodes. erdantic will stop\n            searching for component classes when it reaches these models\n        limit_search_models_to (Optional[Iterable[sr]], optional): Iterable of identifiers of data\n            model classes that erdantic supports. If any are specified, when searching a module,\n            limit data model classes to those ones. Defaults to None which will find all data model\n            classes supported by erdantic.\n    Raises:\n        UnknownModelTypeError: If model is not recognized as a supported model type.\n\n    Returns:\n        EntityRelationshipDiagram: diagram object for given data model.\n    \"\"\"\n    models = []\n    for mm in models_or_modules:\n        if isinstance(mm, type):\n            models.append(mm)\n        elif isinstance(mm, ModuleType):\n            models.extend(find_models(mm, limit_search_models_to=limit_search_models_to))\n        else:\n            raise NotATypeError(f\"Given model is not a type: {mm}\")\n    for terminal_model in tuple(termini):\n        if not isinstance(terminal_model, type):\n            raise NotATypeError(f\"Given terminal model is not a type: {terminal_model}\")\n\n    seen_models: Set[Model] = {adapt_model(t) for t in termini}\n    seen_edges: Set[Edge] = set()\n    for raw_model in models:\n        model = adapt_model(raw_model)\n        search_composition_graph(model=model, seen_models=seen_models, seen_edges=seen_edges)\n    return EntityRelationshipDiagram(models=list(seen_models), edges=list(seen_edges))\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.draw","title":"<code>draw(*models_or_modules, out, termini=[], limit_search_models_to=None, **kwargs)</code>","text":"<p>Render entity relationship diagram for given data model classes to file.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type</code> <p>Data model classes to diagram, or modules containing them.</p> <code>()</code> <code>out</code> <code>Union[str, PathLike]</code> <p>Output file path for rendered diagram.</p> required <code>termini</code> <code>Sequence[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>[]</code> <code>limit_search_models_to</code> <code>Optional[Iterable[sr]]</code> <p>Iterable of identifiers of data model classes that erdantic supports. If any are specified, when searching a module, limit data model classes to those ones. Defaults to None which will find all data model classes supported by erdantic.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to <code>pygraphviz.AGraph.draw</code>.</p> <code>{}</code> Source code in <code>erdantic/erd.py</code> <pre><code>def draw(\n    *models_or_modules: Union[type, ModuleType],\n    out: Union[str, os.PathLike],\n    termini: Sequence[type] = [],\n    limit_search_models_to: Optional[Iterable[str]] = None,\n    **kwargs,\n):\n    \"\"\"Render entity relationship diagram for given data model classes to file.\n\n    Args:\n        *models_or_modules (type): Data model classes to diagram, or modules containing them.\n        out (Union[str, os.PathLike]): Output file path for rendered diagram.\n        termini (Sequence[type]): Data model classes to set as terminal nodes. erdantic will stop\n            searching for component classes when it reaches these models\n        limit_search_models_to (Optional[Iterable[sr]], optional): Iterable of identifiers of data\n            model classes that erdantic supports. If any are specified, when searching a module,\n            limit data model classes to those ones. Defaults to None which will find all data model\n            classes supported by erdantic.\n        **kwargs: Additional keyword arguments to [`pygraphviz.AGraph.draw`](https://pygraphviz.github.io/documentation/latest/reference/agraph.html#pygraphviz.AGraph.draw).\n    \"\"\"\n    diagram = create(\n        *models_or_modules, termini=termini, limit_search_models_to=limit_search_models_to\n    )\n    diagram.draw(out=out, **kwargs)\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.find_models","title":"<code>find_models(module, limit_search_models_to=None)</code>","text":"<p>Searches a module and yields all data model classes found.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>Module to search for data model classes</p> required <code>limit_search_models_to</code> <code>Optional[Iterable[sr]]</code> <p>Iterable of identifiers of data model classes that erdantic supports. If any are specified, when searching a module, limit data model classes to those ones. Defaults to None which will find all data model classes supported by erdantic.</p> <code>None</code> <p>Yields:</p> Type Description <code>type</code> <p>Iterator[type]: Members of module that are data model classes.</p> Source code in <code>erdantic/erd.py</code> <pre><code>def find_models(\n    module: ModuleType, limit_search_models_to: Optional[Iterable[str]] = None\n) -&gt; Iterator[type]:\n    \"\"\"Searches a module and yields all data model classes found.\n\n    Args:\n        module (ModuleType): Module to search for data model classes\n        limit_search_models_to (Optional[Iterable[sr]], optional): Iterable of identifiers of data\n            model classes that erdantic supports. If any are specified, when searching a module,\n            limit data model classes to those ones. Defaults to None which will find all data model\n            classes supported by erdantic.\n\n    Yields:\n        Iterator[type]: Members of module that are data model classes.\n    \"\"\"\n    limit_search_models_to_adapters: Iterable[Type[Model]]\n    if limit_search_models_to is None:\n        limit_search_models_to_adapters = model_adapter_registry.values()\n    else:\n        limit_search_models_to_adapters = [get_model_adapter(m) for m in limit_search_models_to]\n\n    for _, member in inspect.getmembers(module, inspect.isclass):\n        if member.__module__ == module.__name__:\n            for model_adapter in limit_search_models_to_adapters:\n                if model_adapter.is_model_type(member):\n                    yield member\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.search_composition_graph","title":"<code>search_composition_graph(model, seen_models, seen_edges)</code>","text":"<p>Recursively search composition graph for a model, where nodes are models and edges are composition relationships between models. Nodes and edges that are discovered will be added to the two respective provided set instances.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Root node to begin search.</p> required <code>seen_models</code> <code>Set[Model]</code> <p>Set instance that visited nodes will be added to.</p> required <code>seen_edges</code> <code>Set[Edge]</code> <p>Set instance that traversed edges will be added to.</p> required Source code in <code>erdantic/erd.py</code> <pre><code>def search_composition_graph(\n    model: Model,\n    seen_models: Set[Model],\n    seen_edges: Set[Edge],\n):\n    \"\"\"Recursively search composition graph for a model, where nodes are models and edges are\n    composition relationships between models. Nodes and edges that are discovered will be added to\n    the two respective provided set instances.\n\n    Args:\n        model (Model): Root node to begin search.\n        seen_models (Set[Model]): Set instance that visited nodes will be added to.\n        seen_edges (Set[Edge]): Set instance that traversed edges will be added to.\n    \"\"\"\n    if model not in seen_models:\n        seen_models.add(model)\n        for field in model.fields:\n            try:\n                for arg in get_recursive_args(field.type_obj):\n                    try:\n                        field_model = adapt_model(arg)\n                        seen_edges.add(Edge(source=model, source_field=field, target=field_model))\n                        search_composition_graph(field_model, seen_models, seen_edges)\n                    except UnknownModelTypeError:\n                        pass\n            except _UnevaluatedForwardRefError as e:\n                raise UnevaluatedForwardRefError(\n                    model=model, field=field, forward_ref=e.forward_ref\n                ) from None\n            except _StringForwardRefError as e:\n                raise StringForwardRefError(\n                    model=model, field=field, forward_ref=e.forward_ref\n                ) from None\n</code></pre>"},{"location":"api-reference/erd/#erdantic.erd.to_dot","title":"<code>to_dot(*models_or_modules, termini=[], limit_search_models_to=None)</code>","text":"<p>Generate Graphviz DOT language representation of entity relationship diagram for given data model classes.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type</code> <p>Data model classes to diagram, or modules containing them.</p> <code>()</code> <code>termini</code> <code>Sequence[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>[]</code> <code>limit_search_models_to</code> <code>Optional[Iterable[sr]]</code> <p>Iterable of identifiers of data model classes that erdantic supports. If any are specified, when searching a module, limit data model classes to those ones. Defaults to None which will find all data model classes supported by erdantic.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>DOT language representation of diagram</p> Source code in <code>erdantic/erd.py</code> <pre><code>def to_dot(\n    *models_or_modules: Union[type, ModuleType],\n    termini: Sequence[type] = [],\n    limit_search_models_to: Optional[Iterable[str]] = None,\n) -&gt; str:\n    \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation of\n    entity relationship diagram for given data model classes.\n\n    Args:\n        *models_or_modules (type): Data model classes to diagram, or modules containing them.\n        termini (Sequence[type]): Data model classes to set as terminal nodes. erdantic will stop\n            searching for component classes when it reaches these models\n        limit_search_models_to (Optional[Iterable[sr]], optional): Iterable of identifiers of data\n            model classes that erdantic supports. If any are specified, when searching a module,\n            limit data model classes to those ones. Defaults to None which will find all data model\n            classes supported by erdantic.\n\n    Returns:\n        str: DOT language representation of diagram\n    \"\"\"\n    diagram = create(\n        *models_or_modules, termini=termini, limit_search_models_to=limit_search_models_to\n    )\n    return diagram.to_dot()\n</code></pre>"},{"location":"api-reference/examples.dataclasses/","title":"erdantic.examples.dataclasses","text":"<p>Example data model classes using standard library's <code>dataclasses</code> module.</p>"},{"location":"api-reference/examples.dataclasses/#erdantic.examples.dataclasses.Adventurer","title":"<code>Adventurer</code>  <code>dataclass</code>","text":"<p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Adventurer:\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        level (int): Level of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    level: int\n    alignment: Alignment\n</code></pre>"},{"location":"api-reference/examples.dataclasses/#erdantic.examples.dataclasses.Party","title":"<code>Party</code>  <code>dataclass</code>","text":"<p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Party:\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer]\n    active_quest: Optional[Quest]\n</code></pre>"},{"location":"api-reference/examples.dataclasses/#erdantic.examples.dataclasses.Quest","title":"<code>Quest</code>  <code>dataclass</code>","text":"<p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Quest:\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int\n</code></pre>"},{"location":"api-reference/examples.dataclasses/#erdantic.examples.dataclasses.QuestGiver","title":"<code>QuestGiver</code>  <code>dataclass</code>","text":"<p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass QuestGiver:\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str]\n    location: str\n</code></pre>"},{"location":"api-reference/examples.pydantic/","title":"erdantic.examples.pydantic","text":"<p>Example data model classes using Pydantic.</p>"},{"location":"api-reference/examples.pydantic/#erdantic.examples.pydantic.Adventurer","title":"<code>Adventurer</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Adventurer(BaseModel):\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        level (int): Level of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    level: int\n    alignment: Alignment\n</code></pre>"},{"location":"api-reference/examples.pydantic/#erdantic.examples.pydantic.Party","title":"<code>Party</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Party(BaseModel):\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer]\n    active_quest: Optional[Quest]\n</code></pre>"},{"location":"api-reference/examples.pydantic/#erdantic.examples.pydantic.Quest","title":"<code>Quest</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Quest(BaseModel):\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int\n</code></pre>"},{"location":"api-reference/examples.pydantic/#erdantic.examples.pydantic.QuestGiver","title":"<code>QuestGiver</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class QuestGiver(BaseModel):\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str]\n    location: str\n</code></pre>"},{"location":"api-reference/exceptions/","title":"erdantic.exceptions","text":""},{"location":"api-reference/exceptions/#erdantic.exceptions.ErdanticException","title":"<code>ErdanticException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all exceptions from erdantic library.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class ErdanticException(Exception):\n    \"\"\"Base class for all exceptions from erdantic library.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.InvalidFieldError","title":"<code>InvalidFieldError</code>","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when an invalid field object is passed to a field adapter.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class InvalidFieldError(ValueError, ErdanticException):\n    \"\"\"Raised when an invalid field object is passed to a field adapter.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.InvalidModelAdapterError","title":"<code>InvalidModelAdapterError</code>","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when a model adapter is expected but input is not subclassing Model.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class InvalidModelAdapterError(ValueError, ErdanticException):\n    \"\"\"Raised when a model adapter is expected but input is not subclassing Model.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.InvalidModelError","title":"<code>InvalidModelError</code>","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when an invalid model object is passed to a model adapter.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class InvalidModelError(ValueError, ErdanticException):\n    \"\"\"Raised when an invalid model object is passed to a model adapter.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.ModelAdapterNotFoundError","title":"<code>ModelAdapterNotFoundError</code>","text":"<p>             Bases: <code>KeyError</code>, <code>ErdanticException</code></p> <p>Raised when specified key does not match a registered model adapter.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class ModelAdapterNotFoundError(KeyError, ErdanticException):\n    \"\"\"Raised when specified key does not match a registered model adapter.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.ModelOrModuleNotFoundError","title":"<code>ModelOrModuleNotFoundError</code>","text":"<p>             Bases: <code>ImportError</code>, <code>ErdanticException</code></p> <p>Raised when specified fully qualified name of model class or module cannot be found.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class ModelOrModuleNotFoundError(ImportError, ErdanticException):\n    \"\"\"Raised when specified fully qualified name of model class or module cannot be found.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.StringForwardRefError","title":"<code>StringForwardRefError</code>","text":"<p>             Bases: <code>ErdanticException</code></p> <p>Raised when a field's type declaration is stored as a string literal and not transformed into a typing.ForwardRef object.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class StringForwardRefError(ErdanticException):\n    \"\"\"Raised when a field's type declaration is stored as a string literal and not transformed\n    into a typing.ForwardRef object.\"\"\"\n\n    def __init__(self, model: \"Model\", field: \"Field\", forward_ref: ForwardRef) -&gt; None:\n        message = (\n            f\"Forward reference '{forward_ref}' for field '{field.name}' on model '{model.name}' \"\n            \"is a string literal and not a typing.ForwardRef object. erdantic is unable to handle \"\n            \"forward references that aren't transformed into typing.ForwardRef. Declare \"\n            f\"explicitly with 'typing.ForwardRef(\\\"{forward_ref}\\\", is_argument=False)'.\"\n        )\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnevaluatedForwardRefError","title":"<code>UnevaluatedForwardRefError</code>","text":"<p>             Bases: <code>ErdanticException</code></p> <p>Raised when a field's type declaration has an unevaluated forward reference.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnevaluatedForwardRefError(ErdanticException):\n    \"\"\"Raised when a field's type declaration has an unevaluated forward reference.\"\"\"\n\n    def __init__(self, model: \"Model\", field: \"Field\", forward_ref: ForwardRef) -&gt; None:\n        message = (\n            f\"Unevaluated forward reference '{forward_ref.__forward_arg__}' \"\n            f\"for field {field.name} on model {model.name}.\"\n        )\n        if model.forward_ref_help:\n            message += \" \" + model.forward_ref_help\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnknownFieldError","title":"<code>UnknownFieldError</code>","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when specified field does not match a field on specified model.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnknownFieldError(ValueError, ErdanticException):\n    \"\"\"Raised when specified field does not match a field on specified model.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnknownModelTypeError","title":"<code>UnknownModelTypeError</code>","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when a given model does not match known supported class types.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnknownModelTypeError(ValueError, ErdanticException):\n    \"\"\"Raised when a given model does not match known supported class types.\"\"\"\n\n    def __init__(self, model: type, message: Optional[str] = None):\n        if message is None:\n            display = getattr(model, \"__mro__\", str(model))\n            message = f\"Given model does not match any supported types. Model MRO: {display}\"\n        self.model = model\n        self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/pydantic/","title":"erdantic.pydantic","text":""},{"location":"api-reference/pydantic/#erdantic.pydantic.PydanticField","title":"<code>PydanticField</code>","text":"<p>             Bases: <code>Field[FieldInfo]</code></p> <p>Concrete field adapter class for Pydantic fields.</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>ModelField</code> <p>The Pydantic field object that is associated with this adapter instance.</p> Source code in <code>erdantic/pydantic.py</code> <pre><code>class PydanticField(Field[pydantic.fields.FieldInfo]):\n    \"\"\"Concrete field adapter class for Pydantic fields.\n\n    Attributes:\n        field (pydantic.fields.ModelField): The Pydantic field object that is associated with this\n            adapter instance.\n    \"\"\"\n\n    def __init__(self, name: str, field_info: pydantic.fields.FieldInfo):\n        self._name = name\n        if not isinstance(field_info, pydantic.fields.FieldInfo):\n            raise InvalidFieldError(\n                f\"field_info must be of type pydantic.fields.FieldInfo. Got: {type(field_info)}\"\n            )\n        super().__init__(field=field_info)\n\n    @property\n    def name(self) -&gt; str:\n        return self._name\n\n    @property\n    def type_obj(self) -&gt; Union[type, GenericAlias]:\n        return self.field.annotation\n\n    def is_many(self) -&gt; bool:\n        return is_many(self.type_obj)\n\n    def is_nullable(self) -&gt; bool:\n        return is_nullable(self.type_obj)\n</code></pre>"},{"location":"api-reference/pydantic/#erdantic.pydantic.PydanticModel","title":"<code>PydanticModel</code>","text":"<p>             Bases: <code>Model[Type[BaseModel]]</code></p> <p>Concrete model adapter class for a Pydantic <code>BaseModel</code>.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Type[BaseModel]</code> <p>The Pydantic model class that is associated with this adapter instance.</p> <code>forward_ref_help</code> <code>Optional[str]</code> <p>Instructions for how to resolve an unevaluated forward reference in a field's type declaration.</p> Source code in <code>erdantic/pydantic.py</code> <pre><code>@register_model_adapter(\"pydantic\")\nclass PydanticModel(Model[Type[pydantic.BaseModel]]):\n    \"\"\"Concrete model adapter class for a Pydantic\n    [`BaseModel`](https://pydantic-docs.helpmanual.io/usage/models/).\n\n    Attributes:\n        model (Type[pydantic.BaseModel]): The Pydantic model class that is associated with this\n            adapter instance.\n        forward_ref_help (Optional[str]): Instructions for how to resolve an unevaluated forward\n            reference in a field's type declaration.\n    \"\"\"\n\n    forward_ref_help = (\n        \"Call 'update_forward_refs' after model is created to resolve. \"\n        \"See: https://pydantic-docs.helpmanual.io/usage/postponed_annotations/\"\n    )\n\n    def __init__(self, model: Type[pydantic.BaseModel]):\n        if not self.is_model_type(model):\n            raise InvalidModelError(\n                \"Argument model must be a subclass of pydantic.BaseModel. \"\n                f\"Got {repr_type_with_mro(model)}\"\n            )\n        super().__init__(model=model)\n\n    @staticmethod\n    def is_model_type(obj: Any) -&gt; bool:\n        return isinstance(obj, type) and issubclass(obj, pydantic.BaseModel)\n\n    @property\n    def fields(self) -&gt; List[Field]:\n        return [\n            PydanticField(name=name, field_info=field_info)\n            for name, field_info in self.model.model_fields.items()\n        ]\n\n    @property\n    def docstring(self) -&gt; str:\n        out = super().docstring\n        field_descriptions = [field.field.description for field in self.fields]\n        if any(descr is not None for descr in field_descriptions):\n            # Sometimes Pydantic models have field documentation as descriptions as metadata on the\n            # field instead of in the docstring. If detected, construct docstring and add.\n            out += \"\\nAttributes:\\n\"\n            field_defaults = [field.field.default for field in self.fields]\n            for field, descr, default in zip(self.fields, field_descriptions, field_defaults):\n                if descr is not None:\n                    line = f\"{field.name} ({field.type_name}): {descr}\"\n                    if (\n                        not isinstance(default, pydantic_core.PydanticUndefinedType)\n                        and default is not ...\n                    ):\n                        if not line.strip().endswith(\".\"):\n                            line = line.rstrip() + \". \"\n                        else:\n                            line = line.rstrip() + \" \"\n                        if isinstance(default, str):\n                            line += f\"Default is '{default}'.\"\n                        else:\n                            line += f\"Default is {default}.\"\n                    out += \"    \" + line.strip() + \"\\n\"\n\n        return out\n</code></pre>"},{"location":"examples/dataclasses/","title":"Usage Example: dataclasses","text":"In\u00a0[1]: Copied! <pre>import erdantic.examples.dataclasses\n??erdantic.examples.dataclasses\n</pre> import erdantic.examples.dataclasses ??erdantic.examples.dataclasses <pre>Type:        module\nString form: &lt;module 'erdantic.examples.dataclasses' from '/Users/jqi/repos/erdantic/erdantic/examples/dataclasses.py'&gt;\nFile:        ~/repos/erdantic/erdantic/examples/dataclasses.py\nSource:     \n\"\"\"Example data model classes using standard library's\n[`dataclasses`](https://docs.python.org/3/library/dataclasses.html) module.\"\"\"\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional\n\n\nclass Alignment(str, Enum):\n    LAWFUL_GOOD = \"lawful_good\"\n    NEUTRAL_GOOD = \"neutral_good\"\n    CHAOTIC_GOOD = \"chaotic_good\"\n    LAWFUL_NEUTRAL = \"lawful_neutral\"\n    TRUE_NEUTRAL = \"true_neutral\"\n    CHAOTIC_NEUTRAL = \"chaotic_neutral\"\n    LAWFUL_EVIL = \"lawful_evil\"\n    NEUTRAL_EVIL = \"neutral_evil\"\n    CHAOTIC_EVIL = \"chaotic_evil\"\n\n\n@dataclass\nclass Adventurer:\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        level (int): Level of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    level: int\n    alignment: Alignment\n\n\n@dataclass\nclass QuestGiver:\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str]\n    location: str\n\n\n@dataclass\nclass Quest:\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int\n\n\n@dataclass\nclass Party:\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer]\n    active_quest: Optional[Quest]\n</pre> In\u00a0[2]: Copied! <pre>!erdantic erdantic.examples.dataclasses.Party -o diagram.png\n</pre> !erdantic erdantic.examples.dataclasses.Party -o diagram.png <pre>Rendered diagram to diagram.png\n</pre> <p>The format rendered is inferred from the file extension.</p> In\u00a0[3]: Copied! <pre>import erdantic as erd\nfrom erdantic.examples.dataclasses import Party\n\n\ndiagram = erd.create(Party)\ndiagram\n</pre> import erdantic as erd from erdantic.examples.dataclasses import Party   diagram = erd.create(Party) diagram Out[3]: In\u00a0[4]: Copied! <pre>diagram.models\n</pre> diagram.models Out[4]: <pre>[DataClassModel(Adventurer),\n DataClassModel(Party),\n DataClassModel(Quest),\n DataClassModel(QuestGiver)]</pre> In\u00a0[5]: Copied! <pre>diagram.edges\n</pre> diagram.edges Out[5]: <pre>[Edge(source=DataClassModel(Party), source_field=&lt;DataClassField: 'members', List[Adventurer]&gt;, target=DataClassModel(Adventurer)),\n Edge(source=DataClassModel(Party), source_field=&lt;DataClassField: 'active_quest', Optional[Quest]&gt;, target=DataClassModel(Quest)),\n Edge(source=DataClassModel(Quest), source_field=&lt;DataClassField: 'giver', QuestGiver&gt;, target=DataClassModel(QuestGiver))]</pre> <p>You can use the <code>draw</code> method to render the diagram to disk.</p> In\u00a0[6]: Copied! <pre>diagram.draw(\"dataclasses.svg\")\n\n# Equivalently, use erd.draw directly from Party\n# erd.draw(Party, out=\"dataclasses.svg\")\n</pre> diagram.draw(\"dataclasses.svg\")  # Equivalently, use erd.draw directly from Party # erd.draw(Party, out=\"dataclasses.svg\") <p>erdantic uses Graphviz, a venerable open-source C library, to create the diagram. Graphviz uses the DOT language for describing graphs. You use the <code>to_dot</code> method to get the DOT representation as a string.</p> In\u00a0[7]: Copied! <pre>print(diagram.to_dot())\n\n# Equivalently, use erd.to_dot directly from Party\nassert diagram.to_dot() == erd.to_dot(Party)\n</pre> print(diagram.to_dot())  # Equivalently, use erd.to_dot directly from Party assert diagram.to_dot() == erd.to_dot(Party) <pre>digraph \"Entity Relationship Diagram\" {\n\tgraph [fontcolor=gray66,\n\t\tfontsize=9,\n\t\tlabel=\"Created by erdantic v0.2.0 &lt;https://github.com/drivendataorg/erdantic&gt;\",\n\t\tnodesep=0.5,\n\t\trankdir=LR,\n\t\tranksep=1.5\n\t];\n\tnode [fontsize=14,\n\t\tlabel=\"\\N\",\n\t\tshape=plain\n\t];\n\t\"erdantic.examples.dataclasses.Adventurer\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Adventurer&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;profession&lt;/td&gt;&lt;td port=\"profession\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td port=\"level\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alignment&lt;/td&gt;&lt;td port=\"alignment\"&gt;Alignment(str, Enum)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Adventurer&amp;#xA;&amp;#xA;A person often late for dinner but with a tale or two to tell.&amp;#xA;&amp;#xA;Attributes:&amp;#\\\nxA;    name (str): Name of this adventurer&amp;#xA;    profession (str): Profession of this adventurer&amp;#xA;    level (int): Level of \\\nthis adventurer&amp;#xA;    alignment (Alignment): Alignment of this adventurer\"];\n\t\"erdantic.examples.dataclasses.Party\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Party&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;formed_datetime&lt;/td&gt;&lt;td port=\"formed_datetime\"&gt;datetime&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;members&lt;/td&gt;&lt;td port=\"members\"&gt;List[Adventurer]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active_quest&lt;/td&gt;&lt;td port=\"active_quest\"&gt;Optional[Quest]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Party&amp;#xA;&amp;#xA;A group of adventurers finding themselves doing and saying things altogether unexpected.&amp;#\\\nxA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name that party is known by&amp;#xA;    formed_datetime (datetime): Timestamp of when the party \\\nwas formed&amp;#xA;    members (List[Adventurer]): Adventurers that belong to this party&amp;#xA;    active_quest (Optional[Quest]): Current \\\nquest that party is actively tackling\"];\n\t\"erdantic.examples.dataclasses.Party\":members:e -&gt; \"erdantic.examples.dataclasses.Adventurer\":_root:w\t[arrowhead=crowodot];\n\t\"erdantic.examples.dataclasses.Quest\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Quest&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;giver&lt;/td&gt;&lt;td port=\"giver\"&gt;QuestGiver&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reward_gold&lt;/td&gt;&lt;td port=\"reward_gold\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Quest&amp;#xA;&amp;#xA;A task to complete, with some monetary reward.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (str): \\\nName by which this quest is referred to&amp;#xA;    giver (QuestGiver): Person who offered the quest&amp;#xA;    reward_gold (int): Amount \\\nof gold to be rewarded for quest completion\"];\n\t\"erdantic.examples.dataclasses.Party\":active_quest:e -&gt; \"erdantic.examples.dataclasses.Quest\":_root:w\t[arrowhead=noneteeodot];\n\t\"erdantic.examples.dataclasses.QuestGiver\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;QuestGiver&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;faction&lt;/td&gt;&lt;td port=\"faction\"&gt;Optional[str]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;location&lt;/td&gt;&lt;td port=\"location\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.QuestGiver&amp;#xA;&amp;#xA;A person who offers a task that needs completing.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    \\\nname (str): Name of this quest giver&amp;#xA;    faction (str): Faction that this quest giver belongs to&amp;#xA;    location (str): Location \\\nthis quest giver can be found\"];\n\t\"erdantic.examples.dataclasses.Quest\":giver:e -&gt; \"erdantic.examples.dataclasses.QuestGiver\":_root:w\t[arrowhead=noneteetee];\n}\n\n</pre> <p>When using the Python library, pass your terminal node in a list to the <code>termini</code> keyword argument. Below is the Python code for creating diagrams equivalent to the above shell commands.</p> In\u00a0[8]: Copied! <pre>from erdantic.examples.dataclasses import Quest\n\n\nerd.create(Party, termini=[Quest])\n</pre> from erdantic.examples.dataclasses import Quest   erd.create(Party, termini=[Quest]) Out[8]: In\u00a0[9]: Copied! <pre>erd.create(Quest)\n</pre> erd.create(Quest) Out[9]:"},{"location":"examples/dataclasses/#usage-example-dataclasses","title":"Usage Example: dataclasses\u00b6","text":"<p>This notebook shows an example of using erdantic with the standard library's dataclasses module.</p> <p>Let's take a look at the models from the <code>erdantic.examples.dataclasses</code> module. Here's their source code for clariy.</p>"},{"location":"examples/dataclasses/#using-the-cli","title":"Using the CLI\u00b6","text":"<p>The fastest way to rendering a diagram is to use the command-line interface. Below we use IPython's <code>!</code> to run a command in the system shell. We pass the full dotted path to the root class of our composition hierarchy, along with an output file path. erdantic will walk the composition graph to find all child classes.</p>"},{"location":"examples/dataclasses/#using-the-python-library","title":"Using the Python library\u00b6","text":"<p>You can also use the erdantic Python library, which lets you inspect the diagram object. The diagram object even automatically renders in Jupyter notebooks as demonstrated below.</p>"},{"location":"examples/dataclasses/#terminal-models","title":"Terminal Models\u00b6","text":"<p>If you have an enormous composition graph and want to chop it up, you can make that work by specifying models to be terminal nodes.</p> <p>For the CLI, use the <code>-t</code> option to specify a model to be a terminus. To specify more than one, used repeated <code>-t</code> options. So, for example, if you want one diagram rooted by <code>Party</code> that terminates at <code>Quest</code>, and another diagram that is rooted by <code>Quest</code>, you can use the following two shell commands.</p> <pre>erdantic erdantic.examples.dataclasses.Party \\ \n    -t erdantic erdantic.examples.dataclasses.Quest \\\n    -o party.png\nerdantic erdantic.examples.dataclasses.Quest -o quest.png\n</pre>"},{"location":"examples/pydantic/","title":"Usage Example: Pydantic","text":"In\u00a0[1]: Copied! <pre>import erdantic.examples.pydantic\n??erdantic.examples.pydantic\n</pre> import erdantic.examples.pydantic ??erdantic.examples.pydantic <pre>Type:        module\nString form: &lt;module 'erdantic.examples.pydantic' from '/Users/jqi/repos/erdantic/erdantic/examples/pydantic.py'&gt;\nFile:        ~/repos/erdantic/erdantic/examples/pydantic.py\nSource:     \n\"\"\"Example data model classes using [Pydantic](https://pydantic-docs.helpmanual.io/).\"\"\"\n\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Alignment(str, Enum):\n    LAWFUL_GOOD = \"lawful_good\"\n    NEUTRAL_GOOD = \"neutral_good\"\n    CHAOTIC_GOOD = \"chaotic_good\"\n    LAWFUL_NEUTRAL = \"lawful_neutral\"\n    TRUE_NEUTRAL = \"true_neutral\"\n    CHAOTIC_NEUTRAL = \"chaotic_neutral\"\n    LAWFUL_EVIL = \"lawful_evil\"\n    NEUTRAL_EVIL = \"neutral_evil\"\n    CHAOTIC_EVIL = \"chaotic_evil\"\n\n\nclass Adventurer(BaseModel):\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        level (int): Level of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    level: int\n    alignment: Alignment\n\n\nclass QuestGiver(BaseModel):\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str]\n    location: str\n\n\nclass Quest(BaseModel):\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int\n\n\nclass Party(BaseModel):\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer]\n    active_quest: Optional[Quest]\n</pre> In\u00a0[2]: Copied! <pre>!erdantic erdantic.examples.pydantic.Party -o diagram.png\n</pre> !erdantic erdantic.examples.pydantic.Party -o diagram.png <pre>Rendered diagram to diagram.png\n</pre> <p>The format rendered is inferred from the file extension.</p> In\u00a0[3]: Copied! <pre>import erdantic as erd\nfrom erdantic.examples.pydantic import Party\n\n\ndiagram = erd.create(Party)\ndiagram\n</pre> import erdantic as erd from erdantic.examples.pydantic import Party   diagram = erd.create(Party) diagram Out[3]: In\u00a0[4]: Copied! <pre>diagram.models\n</pre> diagram.models Out[4]: <pre>[PydanticModel(Adventurer),\n PydanticModel(Party),\n PydanticModel(Quest),\n PydanticModel(QuestGiver)]</pre> In\u00a0[5]: Copied! <pre>diagram.edges\n</pre> diagram.edges Out[5]: <pre>[Edge(source=PydanticModel(Party), source_field=&lt;PydanticField: 'members', List[Adventurer]&gt;, target=PydanticModel(Adventurer)),\n Edge(source=PydanticModel(Party), source_field=&lt;PydanticField: 'active_quest', Optional[Quest]&gt;, target=PydanticModel(Quest)),\n Edge(source=PydanticModel(Quest), source_field=&lt;PydanticField: 'giver', QuestGiver&gt;, target=PydanticModel(QuestGiver))]</pre> <p>You can use the <code>draw</code> method to render the diagram to disk.</p> In\u00a0[6]: Copied! <pre>diagram.draw(\"pydantic.svg\")\n\n# Equivalently, use erd.draw directly from Party\n# erd.draw(Party, out=\"pydantic.svg\")\n</pre> diagram.draw(\"pydantic.svg\")  # Equivalently, use erd.draw directly from Party # erd.draw(Party, out=\"pydantic.svg\") <p>erdantic uses Graphviz, a venerable open-source C library, to create the diagram. Graphviz uses the DOT language for describing graphs. You use the <code>to_dot</code> method to get the DOT representation as a string.</p> In\u00a0[7]: Copied! <pre>print(diagram.to_dot())\n\n# Equivalently, use erd.to_dot directly from Party\nassert diagram.to_dot() == erd.to_dot(Party)\n</pre> print(diagram.to_dot())  # Equivalently, use erd.to_dot directly from Party assert diagram.to_dot() == erd.to_dot(Party) <pre>digraph \"Entity Relationship Diagram\" {\n\tgraph [fontcolor=gray66,\n\t\tfontsize=9,\n\t\tlabel=\"Created by erdantic v0.2.0 &lt;https://github.com/drivendataorg/erdantic&gt;\",\n\t\tnodesep=0.5,\n\t\trankdir=LR,\n\t\tranksep=1.5\n\t];\n\tnode [fontsize=14,\n\t\tlabel=\"\\N\",\n\t\tshape=plain\n\t];\n\t\"erdantic.examples.pydantic.Adventurer\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Adventurer&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;profession&lt;/td&gt;&lt;td port=\"profession\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td port=\"level\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alignment&lt;/td&gt;&lt;td port=\"alignment\"&gt;Alignment(str, Enum)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Adventurer&amp;#xA;&amp;#xA;A person often late for dinner but with a tale or two to tell.&amp;#xA;&amp;#xA;Attributes:&amp;#\\\nxA;    name (str): Name of this adventurer&amp;#xA;    profession (str): Profession of this adventurer&amp;#xA;    level (int): Level of \\\nthis adventurer&amp;#xA;    alignment (Alignment): Alignment of this adventurer\"];\n\t\"erdantic.examples.pydantic.Party\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Party&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;formed_datetime&lt;/td&gt;&lt;td port=\"formed_datetime\"&gt;datetime&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;members&lt;/td&gt;&lt;td port=\"members\"&gt;List[Adventurer]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active_quest&lt;/td&gt;&lt;td port=\"active_quest\"&gt;Optional[Quest]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Party&amp;#xA;&amp;#xA;A group of adventurers finding themselves doing and saying things altogether unexpected.&amp;#\\\nxA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name that party is known by&amp;#xA;    formed_datetime (datetime): Timestamp of when the party \\\nwas formed&amp;#xA;    members (List[Adventurer]): Adventurers that belong to this party&amp;#xA;    active_quest (Optional[Quest]): Current \\\nquest that party is actively tackling\"];\n\t\"erdantic.examples.pydantic.Party\":members:e -&gt; \"erdantic.examples.pydantic.Adventurer\":_root:w\t[arrowhead=crowodot];\n\t\"erdantic.examples.pydantic.Quest\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Quest&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;giver&lt;/td&gt;&lt;td port=\"giver\"&gt;QuestGiver&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reward_gold&lt;/td&gt;&lt;td port=\"reward_gold\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Quest&amp;#xA;&amp;#xA;A task to complete, with some monetary reward.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (str): \\\nName by which this quest is referred to&amp;#xA;    giver (QuestGiver): Person who offered the quest&amp;#xA;    reward_gold (int): Amount \\\nof gold to be rewarded for quest completion\"];\n\t\"erdantic.examples.pydantic.Party\":active_quest:e -&gt; \"erdantic.examples.pydantic.Quest\":_root:w\t[arrowhead=noneteeodot];\n\t\"erdantic.examples.pydantic.QuestGiver\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;QuestGiver&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;faction&lt;/td&gt;&lt;td port=\"faction\"&gt;Optional[str]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;location&lt;/td&gt;&lt;td port=\"location\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.QuestGiver&amp;#xA;&amp;#xA;A person who offers a task that needs completing.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (\\\nstr): Name of this quest giver&amp;#xA;    faction (str): Faction that this quest giver belongs to&amp;#xA;    location (str): Location \\\nthis quest giver can be found\"];\n\t\"erdantic.examples.pydantic.Quest\":giver:e -&gt; \"erdantic.examples.pydantic.QuestGiver\":_root:w\t[arrowhead=noneteetee];\n}\n\n</pre> <p>When using the Python library, pass your terminal node in a list to the <code>termini</code> keyword argument. Below is the Python code for creating diagrams equivalent to the above shell commands.</p> In\u00a0[8]: Copied! <pre>from erdantic.examples.pydantic import Quest\n\n\nerd.create(Party, termini=[Quest])\n</pre> from erdantic.examples.pydantic import Quest   erd.create(Party, termini=[Quest]) Out[8]: In\u00a0[9]: Copied! <pre>erd.create(Quest)\n</pre> erd.create(Quest) Out[9]:"},{"location":"examples/pydantic/#usage-example-pydantic","title":"Usage Example: Pydantic\u00b6","text":"<p>This notebook shows an example of using erdantic with Pydantic models.</p> <p>Let's take a look at the models from the <code>erdantic.examples.pydantic</code> module. Here's their source code for clariy.</p>"},{"location":"examples/pydantic/#using-the-cli","title":"Using the CLI\u00b6","text":"<p>The fastest way to rendering a diagram is to use the command-line interface. Below we use IPython's <code>!</code> to run a command in the system shell. We pass the full dotted path to the root class of our composition hierarchy, along with an output file path. erdantic will walk the composition graph to find all child classes.</p>"},{"location":"examples/pydantic/#using-the-python-library","title":"Using the Python library\u00b6","text":"<p>You can also use the erdantic Python library, which lets you inspect the diagram object. The diagram object even automatically renders in Jupyter notebooks as demonstrated below.</p>"},{"location":"examples/pydantic/#terminal-models","title":"Terminal Models\u00b6","text":"<p>If you have an enormous composition graph and want to chop it up, you can make that work by specifying models to be terminal nodes.</p> <p>For the CLI, use the <code>-t</code> option to specify a model to be a terminus. To specify more than one, used repeated <code>-t</code> options. So, for example, if you want one diagram rooted by <code>Party</code> that terminates at <code>Quest</code>, and another diagram that is rooted by <code>Quest</code>, you can use the following two shell commands.</p> <pre>erdantic erdantic.examples.pydantic.Party \\ \n    -t erdantic erdantic.examples.pydantic.Quest \\\n    -o party.png\nerdantic erdantic.examples.pydantic.Quest -o quest.png\n</pre>"}]}